### 표준 API 엔드포인트 설계 제안

| 기능 (Feature) | HTTP 메소드 | API 엔드포인트 경로 | 설명 |
| :--- | :--- | :--- | :--- |
| **회원 가입** | `POST` | `/api/v1/auth/signup` | 새로운 사용자를 생성합니다. `auth` 경로에 두어 인증 관련 기능임을 명시합니다. |
| **로그인** | `POST` | `/api/v1/auth/login` | 이메일/비밀번호로 인증 후, Access/Refresh 토큰을 발급받습니다. |
| **로그아웃** | `POST` | `/api/v1/auth/logout` | 서버에 저장된 Refresh Token을 무효화하고, 클라이언트의 토큰을 삭제하도록 유도합니다. |
| **토큰 재발급** | `POST` | `/api/v1/auth/refresh` | 유효한 Refresh Token을 보내 새로운 Access Token을 재발급받습니다. |
| **내 정보 조회** | `GET` | `/api/v1/users/me` | 현재 인증된 '나' 자신의 정보를 조회합니다. `me`는 특수한 식별자입니다. |
| **내 정보 수정** | `PATCH` | `/api/v1/users/me` | 현재 인증된 '나' 자신의 정보(닉네임, 프로필 사진 등)를 수정합니다. |
| **비밀번호 변경** | `PATCH` | `/api/v1/users/me/password` | 현재 인증된 '나' 자신의 비밀번호를 변경합니다. |
| **회원 탈퇴** | `DELETE` | `/api/v1/users/me` | 현재 인증된 '나' 자신의 계정을 삭제합니다. |

---

### 소셜 로그인 (OIDC) 흐름

소셜 로그인은 단일 엔드포인트가 아니라 정해진 흐름(Flow)에 따라 동작합니다. Spring Security의 표준을 따르는 것이 가장 좋습니다.

1.  **로그인 시작 (프론트엔드 -> 백엔드)**
    *   **경로**: `GET /oauth2/authorization/{provider}`
    *   **설명**: 사용자가 "Google 로그인" 버튼 등을 클릭하면, 프론트엔드는 이 경로로 요청을 보냅니다. `{provider}`에는 `google`, `kakao`, `naver` 등이 들어갑니다. 그러면 백엔드 서버가 사용자를 해당 소셜 서비스의 실제 로그인 페이지로 리다이렉트시켜 줍니다.

2.  **로그인 결과 콜백 (소셜 서비스 -> 백엔드)**
    *   **경로**: `GET /login/oauth2/code/{provider}`
    *   **설명**: 사용자가 소셜 서비스에서 로그인을 성공하면, 해당 서비스가 이 콜백 경로로 리다이렉트하여 인증 코드를 보내줍니다. 백엔드는 이 코드를 받아 소셜 서비스와 통신하여 사용자 정보를 얻어오고, 우리 서비스에 가입시키거나 로그인 처리 후 토큰을 발급합니다.

### 이 설계의 장점

*   **명확한 책임 분리**: `/auth`는 인증/세션 관리, `/users`는 사용자 정보 관리를 담당합니다.
*   **RESTful 원칙**: 리소스(자원) 중심으로 경로를 설계하여 일관성이 있습니다. (`users`라는 리소스)
*   **보안**: `내 정보`, `탈퇴` 등 민감한 작업은 `/users/{userId}`처럼 ID를 받는 대신, 토큰으로 식별된 `me`를 사용하여 다른 사용자의 정보를 건드릴 가능성을 원천 차단합니다.
*   **표준**: 업계에서 널리 쓰이는 검증된 방식이라 다른 개발자가 이해하기 쉽습니다.
